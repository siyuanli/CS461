Opening files...
Parsing specification from standard input...
Checking specification...
Warning: Terminal "LEX_ERROR" was declared but never used
Building parse tables...
  Computing non-terminal nullability...
  Computing first sets...
  Building state machine...
  Filling in tables...
*** Reduce/Reduce conflict found in state #6
  between member_list ::= (*) 
  and     NT$0 ::= (*) 
  under symbols: {ID}
  Resolved in favor of the second production.

*** Shift/Reduce conflict found in state #6
  between member_list ::= (*) 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #6
  between NT$0 ::= (*) 
  under symbol ID
  Resolved in favor of shifting.

*** Reduce/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  and     stmt_list ::= (*) 
  under symbols: {IF, WHILE, FOR, BREAK, NEW, RETURN, MINUS, NOT, INCR, DECR, LPAREN, LBRACE, ID, INT_CONST, BOOLEAN_CONST, STRING_CONST}
  Resolved in favor of the first production.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol IF
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol WHILE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol FOR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol BREAK
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol NEW
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol RETURN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol MINUS
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol NOT
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol INCR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol DECR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol LPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol LBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol INT_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol BOOLEAN_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between NT$2 ::= (*) 
  under symbol STRING_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol IF
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol WHILE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol FOR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol BREAK
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol NEW
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol RETURN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol MINUS
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol NOT
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol INCR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol DECR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol LPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol LBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol INT_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol BOOLEAN_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #144
  between stmt_list ::= (*) 
  under symbol STRING_CONST
  Resolved in favor of shifting.

*** Reduce/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  and     stmt_list ::= (*) 
  under symbols: {IF, WHILE, FOR, BREAK, NEW, RETURN, MINUS, NOT, INCR, DECR, LPAREN, LBRACE, ID, INT_CONST, BOOLEAN_CONST, STRING_CONST}
  Resolved in favor of the first production.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol IF
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol WHILE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol FOR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol BREAK
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol NEW
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol RETURN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol MINUS
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol NOT
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol INCR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol DECR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol LPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol LBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol INT_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol BOOLEAN_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between NT$2 ::= (*) 
  under symbol STRING_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol IF
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol WHILE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol FOR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol BREAK
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol NEW
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol RETURN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol MINUS
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol NOT
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol INCR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol DECR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol LPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol LBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol INT_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol BOOLEAN_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #159
  between stmt_list ::= (*) 
  under symbol STRING_CONST
  Resolved in favor of shifting.

*** Reduce/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  and     stmt_list ::= (*) 
  under symbols: {IF, WHILE, FOR, BREAK, NEW, RETURN, MINUS, NOT, INCR, DECR, LPAREN, LBRACE, ID, INT_CONST, BOOLEAN_CONST, STRING_CONST}
  Resolved in favor of the first production.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol IF
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol WHILE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol FOR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol BREAK
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol NEW
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol RETURN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol MINUS
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol NOT
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol INCR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol DECR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol LPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol LBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol INT_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol BOOLEAN_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between NT$2 ::= (*) 
  under symbol STRING_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol IF
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol WHILE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol FOR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol BREAK
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol NEW
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol RETURN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol MINUS
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol NOT
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol INCR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol DECR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol LPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol LBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol INT_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol BOOLEAN_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #229
  between stmt_list ::= (*) 
  under symbol STRING_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #38
  between var_expr ::= ID (*) 
  and     array_expr ::= ID (*) ID LSQBRACE expr RSQBRACE 
  under symbol ID
  Resolved in favor of shifting.

*** Reduce/Reduce conflict found in state #9
  between member_list ::= (*) 
  and     NT$0 ::= (*) 
  under symbols: {ID}
  Resolved in favor of the second production.

*** Shift/Reduce conflict found in state #9
  between member_list ::= (*) 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #9
  between NT$0 ::= (*) 
  under symbol ID
  Resolved in favor of shifting.

  Checking for non-reduced productions...
*** More conflicts encountered than expected -- parser generation aborted
===== Terminals =====
[0]EOF [1]error [2]LEX_ERROR [3]CLASS [4]EXTENDS 
[5]IF [6]ELSE [7]WHILE [8]FOR [9]BREAK 
[10]NEW [11]RETURN [12]INSTANCEOF [13]PLUS [14]MINUS 
[15]TIMES [16]DIVIDE [17]MODULUS [18]NOT [19]AND 
[20]OR [21]EQ [22]NE [23]LT [24]LEQ 
[25]GT [26]GEQ [27]ASSIGN [28]INCR [29]DECR 
[30]LPAREN [31]RPAREN [32]LBRACE [33]RBRACE [34]LSQBRACE 
[35]RSQBRACE [36]SEMI [37]COMMA [38]DOT [39]ID 
[40]INT_CONST [41]BOOLEAN_CONST [42]STRING_CONST 

===== Non terminals =====
[0]$START [1]program [2]class_list [3]class [4]member_list 
[5]member [6]method [7]field [8]formal_list [9]formal 
[10]stmt_list [11]stmt [12]expr_stmt [13]decl_stmt [14]if_stmt 
[15]while_stmt [16]for_stmt [17]break_stmt [18]return_stmt [19]block_stmt 
[20]expr [21]assign_expr [22]dispatch_expr [23]expr_list [24]new_expr 
[25]instance_of_expr [26]cast_expr [27]binary_expr [28]unary_expr [29]const_expr 
[30]binary_arith_expr [31]binary_comp_expr [32]binary_logic_expr [33]unary_neg_expr [34]unary_not_expr 
[35]unary_incr_expr [36]unary_decr_expr [37]var_expr [38]array_expr [39]array_assign_expr 
[40]NT$0 [41]NT$1 [42]NT$2 

===== Productions =====
[0] program ::= class_list 
[1] $START ::= program EOF 
[2] class_list ::= class 
[3] class_list ::= class_list class 
[4] class ::= CLASS ID LBRACE member_list RBRACE 
[5] class ::= CLASS ID EXTENDS ID LBRACE member_list RBRACE 
[6] NT$0 ::= 
[7] member_list ::= NT$0 member 
[8] member_list ::= 
[9] member_list ::= member_list member 
[10] member ::= method 
[11] member ::= field 
[12] method ::= ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE 
[13] method ::= ID LSQBRACE RSQBRACE ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE 
[14] field ::= ID ID SEMI 
[15] field ::= ID ID ASSIGN expr SEMI 
[16] field ::= ID LSQBRACE RSQBRACE ID SEMI 
[17] field ::= ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI 
[18] NT$1 ::= 
[19] formal_list ::= NT$1 formal 
[20] formal_list ::= 
[21] formal_list ::= formal_list COMMA formal 
[22] formal ::= ID LSQBRACE RSQBRACE ID 
[23] formal ::= ID ID 
[24] NT$2 ::= 
[25] stmt_list ::= NT$2 stmt 
[26] stmt_list ::= 
[27] stmt_list ::= stmt_list stmt 
[28] stmt ::= expr_stmt 
[29] stmt ::= decl_stmt 
[30] stmt ::= if_stmt 
[31] stmt ::= while_stmt 
[32] stmt ::= for_stmt 
[33] stmt ::= break_stmt 
[34] stmt ::= return_stmt 
[35] stmt ::= block_stmt 
[36] expr_stmt ::= expr SEMI 
[37] decl_stmt ::= ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI 
[38] decl_stmt ::= ID ID ASSIGN expr SEMI 
[39] if_stmt ::= IF LPAREN expr RPAREN stmt 
[40] if_stmt ::= IF LPAREN expr RPAREN stmt ELSE stmt 
[41] while_stmt ::= WHILE LPAREN expr RPAREN stmt 
[42] for_stmt ::= FOR LPAREN SEMI SEMI RPAREN stmt 
[43] for_stmt ::= FOR LPAREN expr SEMI SEMI RPAREN stmt 
[44] for_stmt ::= FOR LPAREN SEMI expr SEMI RPAREN stmt 
[45] for_stmt ::= FOR LPAREN expr SEMI expr SEMI RPAREN stmt 
[46] for_stmt ::= FOR LPAREN SEMI SEMI expr RPAREN stmt 
[47] for_stmt ::= FOR LPAREN expr SEMI SEMI expr RPAREN stmt 
[48] for_stmt ::= FOR LPAREN SEMI expr SEMI expr RPAREN stmt 
[49] for_stmt ::= FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt 
[50] break_stmt ::= BREAK SEMI 
[51] return_stmt ::= RETURN expr 
[52] block_stmt ::= LBRACE stmt_list RBRACE 
[53] expr ::= assign_expr 
[54] expr ::= dispatch_expr 
[55] expr ::= new_expr 
[56] expr ::= instance_of_expr 
[57] expr ::= cast_expr 
[58] expr ::= binary_expr 
[59] expr ::= unary_expr 
[60] expr ::= const_expr 
[61] expr ::= var_expr 
[62] expr ::= LPAREN expr RPAREN 
[63] assign_expr ::= var_expr ASSIGN expr 
[64] assign_expr ::= ID DOT ID ASSIGN expr 
[65] assign_expr ::= array_assign_expr 
[66] dispatch_expr ::= ID LPAREN expr_list RPAREN 
[67] dispatch_expr ::= expr DOT ID LPAREN expr_list RPAREN 
[68] new_expr ::= NEW ID LPAREN RPAREN 
[69] instance_of_expr ::= expr INSTANCEOF ID 
[70] instance_of_expr ::= expr INSTANCEOF ID LSQBRACE RSQBRACE 
[71] cast_expr ::= LPAREN ID RPAREN LPAREN expr RPAREN 
[72] cast_expr ::= LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN 
[73] binary_expr ::= binary_arith_expr 
[74] binary_expr ::= binary_comp_expr 
[75] binary_expr ::= binary_logic_expr 
[76] unary_expr ::= unary_neg_expr 
[77] unary_expr ::= unary_not_expr 
[78] unary_expr ::= unary_incr_expr 
[79] unary_expr ::= unary_decr_expr 
[80] const_expr ::= INT_CONST 
[81] const_expr ::= BOOLEAN_CONST 
[82] const_expr ::= STRING_CONST 
[83] binary_arith_expr ::= expr PLUS expr 
[84] binary_arith_expr ::= expr MINUS expr 
[85] binary_arith_expr ::= expr TIMES expr 
[86] binary_arith_expr ::= expr DIVIDE expr 
[87] binary_arith_expr ::= expr MODULUS expr 
[88] binary_comp_expr ::= expr EQ expr 
[89] binary_comp_expr ::= expr NE expr 
[90] binary_comp_expr ::= expr LT expr 
[91] binary_comp_expr ::= expr LEQ expr 
[92] binary_comp_expr ::= expr GT expr 
[93] binary_comp_expr ::= expr GEQ expr 
[94] binary_logic_expr ::= expr AND expr 
[95] binary_logic_expr ::= expr OR expr 
[96] unary_neg_expr ::= MINUS expr 
[97] unary_not_expr ::= NOT expr 
[98] unary_incr_expr ::= INCR expr 
[99] unary_incr_expr ::= expr INCR 
[100] unary_decr_expr ::= DECR expr 
[101] unary_decr_expr ::= expr DECR 
[102] var_expr ::= ID DOT ID 
[103] var_expr ::= ID 
[104] var_expr ::= array_expr 
[105] array_expr ::= ID LSQBRACE expr RSQBRACE 
[106] array_expr ::= ID ID LSQBRACE expr RSQBRACE 
[107] array_assign_expr ::= ID LSQBRACE expr RSQBRACE ASSIGN expr 
[108] array_assign_expr ::= ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr 

===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [class ::= (*) CLASS ID EXTENDS ID LBRACE member_list RBRACE , {EOF CLASS }]
  [class_list ::= (*) class , {EOF CLASS }]
  [class ::= (*) CLASS ID LBRACE member_list RBRACE , {EOF CLASS }]
  [$START ::= (*) program EOF , {EOF }]
  [class_list ::= (*) class_list class , {EOF CLASS }]
  [program ::= (*) class_list , {EOF }]
}
transition on CLASS to state [4]
transition on class to state [3]
transition on program to state [2]
transition on class_list to state [1]

-------------------
lalr_state [1]: {
  [class ::= (*) CLASS ID EXTENDS ID LBRACE member_list RBRACE , {EOF CLASS }]
  [class ::= (*) CLASS ID LBRACE member_list RBRACE , {EOF CLASS }]
  [class_list ::= class_list (*) class , {EOF CLASS }]
  [program ::= class_list (*) , {EOF }]
}
transition on CLASS to state [4]
transition on class to state [236]

-------------------
lalr_state [2]: {
  [$START ::= program (*) EOF , {EOF }]
}
transition on EOF to state [235]

-------------------
lalr_state [3]: {
  [class_list ::= class (*) , {EOF CLASS }]
}

-------------------
lalr_state [4]: {
  [class ::= CLASS (*) ID EXTENDS ID LBRACE member_list RBRACE , {EOF CLASS }]
  [class ::= CLASS (*) ID LBRACE member_list RBRACE , {EOF CLASS }]
}
transition on ID to state [5]

-------------------
lalr_state [5]: {
  [class ::= CLASS ID (*) LBRACE member_list RBRACE , {EOF CLASS }]
  [class ::= CLASS ID (*) EXTENDS ID LBRACE member_list RBRACE , {EOF CLASS }]
}
transition on EXTENDS to state [7]
transition on LBRACE to state [6]

-------------------
lalr_state [6]: {
  [member_list ::= (*) , {RBRACE ID }]
  [class ::= CLASS ID LBRACE (*) member_list RBRACE , {EOF CLASS }]
  [member_list ::= (*) NT$0 member , {RBRACE ID }]
  [member_list ::= (*) member_list member , {RBRACE ID }]
  [NT$0 ::= (*) , {ID }]
}
transition on member_list to state [233]
transition on NT$0 to state [10]

-------------------
lalr_state [7]: {
  [class ::= CLASS ID EXTENDS (*) ID LBRACE member_list RBRACE , {EOF CLASS }]
}
transition on ID to state [8]

-------------------
lalr_state [8]: {
  [class ::= CLASS ID EXTENDS ID (*) LBRACE member_list RBRACE , {EOF CLASS }]
}
transition on LBRACE to state [9]

-------------------
lalr_state [9]: {
  [member_list ::= (*) , {RBRACE ID }]
  [member_list ::= (*) NT$0 member , {RBRACE ID }]
  [member_list ::= (*) member_list member , {RBRACE ID }]
  [class ::= CLASS ID EXTENDS ID LBRACE (*) member_list RBRACE , {EOF CLASS }]
  [NT$0 ::= (*) , {ID }]
}
transition on member_list to state [11]
transition on NT$0 to state [10]

-------------------
lalr_state [10]: {
  [field ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= (*) ID ID SEMI , {RBRACE ID }]
  [member ::= (*) field , {RBRACE ID }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID SEMI , {RBRACE ID }]
  [method ::= (*) ID LSQBRACE RSQBRACE ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [member_list ::= NT$0 (*) member , {RBRACE ID }]
  [member ::= (*) method , {RBRACE ID }]
  [field ::= (*) ID ID ASSIGN expr SEMI , {RBRACE ID }]
  [method ::= (*) ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on member to state [232]
transition on method to state [16]
transition on field to state [14]
transition on ID to state [12]

-------------------
lalr_state [11]: {
  [field ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= (*) ID ID SEMI , {RBRACE ID }]
  [member ::= (*) field , {RBRACE ID }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID SEMI , {RBRACE ID }]
  [method ::= (*) ID LSQBRACE RSQBRACE ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [member ::= (*) method , {RBRACE ID }]
  [field ::= (*) ID ID ASSIGN expr SEMI , {RBRACE ID }]
  [member_list ::= member_list (*) member , {RBRACE ID }]
  [method ::= (*) ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [class ::= CLASS ID EXTENDS ID LBRACE member_list (*) RBRACE , {EOF CLASS }]
}
transition on method to state [16]
transition on member to state [15]
transition on field to state [14]
transition on RBRACE to state [13]
transition on ID to state [12]

-------------------
lalr_state [12]: {
  [field ::= ID (*) LSQBRACE RSQBRACE ID SEMI , {RBRACE ID }]
  [method ::= ID (*) LSQBRACE RSQBRACE ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [field ::= ID (*) ID ASSIGN expr SEMI , {RBRACE ID }]
  [method ::= ID (*) ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [field ::= ID (*) LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= ID (*) ID SEMI , {RBRACE ID }]
}
transition on LSQBRACE to state [18]
transition on ID to state [17]

-------------------
lalr_state [13]: {
  [class ::= CLASS ID EXTENDS ID LBRACE member_list RBRACE (*) , {EOF CLASS }]
}

-------------------
lalr_state [14]: {
  [member ::= field (*) , {RBRACE ID }]
}

-------------------
lalr_state [15]: {
  [member_list ::= member_list member (*) , {RBRACE ID }]
}

-------------------
lalr_state [16]: {
  [member ::= method (*) , {RBRACE ID }]
}

-------------------
lalr_state [17]: {
  [field ::= ID ID (*) ASSIGN expr SEMI , {RBRACE ID }]
  [method ::= ID ID (*) LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [field ::= ID ID (*) SEMI , {RBRACE ID }]
}
transition on ASSIGN to state [224]
transition on LPAREN to state [223]
transition on SEMI to state [222]

-------------------
lalr_state [18]: {
  [method ::= ID LSQBRACE (*) RSQBRACE ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [field ::= ID LSQBRACE (*) RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= ID LSQBRACE (*) RSQBRACE ID SEMI , {RBRACE ID }]
}
transition on RSQBRACE to state [19]

-------------------
lalr_state [19]: {
  [field ::= ID LSQBRACE RSQBRACE (*) ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= ID LSQBRACE RSQBRACE (*) ID SEMI , {RBRACE ID }]
  [method ::= ID LSQBRACE RSQBRACE (*) ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on ID to state [20]

-------------------
lalr_state [20]: {
  [field ::= ID LSQBRACE RSQBRACE ID (*) ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= ID LSQBRACE RSQBRACE ID (*) SEMI , {RBRACE ID }]
  [method ::= ID LSQBRACE RSQBRACE ID (*) LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on ASSIGN to state [23]
transition on LPAREN to state [22]
transition on SEMI to state [21]

-------------------
lalr_state [21]: {
  [field ::= ID LSQBRACE RSQBRACE ID SEMI (*) , {RBRACE ID }]
}

-------------------
lalr_state [22]: {
  [formal_list ::= (*) NT$1 formal , {RPAREN COMMA }]
  [formal_list ::= (*) formal_list COMMA formal , {RPAREN COMMA }]
  [NT$1 ::= (*) , {ID }]
  [formal_list ::= (*) , {RPAREN COMMA }]
  [method ::= ID LSQBRACE RSQBRACE ID LPAREN (*) formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on NT$1 to state [135]
transition on formal_list to state [134]

-------------------
lalr_state [23]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [field ::= ID LSQBRACE RSQBRACE ID ASSIGN (*) expr SEMI , {RBRACE ID }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [28]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [24]: {
  [const_expr ::= STRING_CONST (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [25]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= INCR (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [133]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [26]: {
  [expr ::= assign_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [27]: {
  [expr ::= cast_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [28]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [field ::= ID LSQBRACE RSQBRACE ID ASSIGN expr (*) SEMI , {RBRACE ID }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on SEMI to state [132]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [29]: {
  [unary_expr ::= unary_decr_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [30]: {
  [expr ::= instance_of_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [31]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= NOT (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [131]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [32]: {
  [expr ::= new_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [33]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= DECR (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [130]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [34]: {
  [const_expr ::= BOOLEAN_CONST (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [35]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= LPAREN (*) ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= LPAREN (*) expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= LPAREN (*) ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [118]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [117]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [36]: {
  [expr ::= var_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= var_expr (*) ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ASSIGN to state [115]

-------------------
lalr_state [37]: {
  [assign_expr ::= array_assign_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [38]: {
  [array_expr ::= ID (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= ID (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= ID (*) DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= ID (*) DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= ID (*) LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= ID (*) DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= ID (*) LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= ID (*) LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on DOT to state [97]
transition on LPAREN to state [96]
transition on LSQBRACE to state [95]
transition on ID to state [94]

-------------------
lalr_state [39]: {
  [const_expr ::= INT_CONST (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [40]: {
  [expr ::= unary_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [41]: {
  [binary_expr ::= binary_comp_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [42]: {
  [unary_expr ::= unary_incr_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [43]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= MINUS (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [56]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [44]: {
  [unary_expr ::= unary_neg_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [45]: {
  [unary_expr ::= unary_not_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [46]: {
  [expr ::= dispatch_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [47]: {
  [binary_expr ::= binary_arith_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [48]: {
  [new_expr ::= NEW (*) ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ID to state [53]

-------------------
lalr_state [49]: {
  [var_expr ::= array_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [50]: {
  [expr ::= const_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [51]: {
  [binary_expr ::= binary_logic_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [52]: {
  [expr ::= binary_expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [53]: {
  [new_expr ::= NEW ID (*) LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [54]

-------------------
lalr_state [54]: {
  [new_expr ::= NEW ID LPAREN (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on RPAREN to state [55]

-------------------
lalr_state [55]: {
  [new_expr ::= NEW ID LPAREN RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [56]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= MINUS expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [57]: {
  [unary_incr_expr ::= expr INCR (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [58]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr AND (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [93]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [59]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr MINUS (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [92]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [60]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr DIVIDE (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [91]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [61]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr MODULUS (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [90]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [62]: {
  [unary_decr_expr ::= expr DECR (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [63]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr EQ (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [89]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [64]: {
  [instance_of_expr ::= expr INSTANCEOF (*) ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr INSTANCEOF (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ID to state [86]

-------------------
lalr_state [65]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr PLUS (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [85]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [66]: {
  [dispatch_expr ::= expr DOT (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ID to state [81]

-------------------
lalr_state [67]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr GT (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [80]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [68]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr TIMES (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [79]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [69]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr NE (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [78]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [70]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr GEQ (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [77]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [71]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr LT (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [76]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [72]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr OR (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [75]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [73]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr LEQ (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [74]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [74]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr LEQ expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [75]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr OR expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [76]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr LT expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [77]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr GEQ expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [78]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr NE expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [79]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr TIMES expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [80]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr GT expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [81]: {
  [dispatch_expr ::= expr DOT ID (*) LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [82]

-------------------
lalr_state [82]: {
  [dispatch_expr ::= expr DOT ID LPAREN (*) expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on expr_list to state [83]

-------------------
lalr_state [83]: {
  [dispatch_expr ::= expr DOT ID LPAREN expr_list (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on RPAREN to state [84]

-------------------
lalr_state [84]: {
  [dispatch_expr ::= expr DOT ID LPAREN expr_list RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [85]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr PLUS expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [86]: {
  [instance_of_expr ::= expr INSTANCEOF ID (*) LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr INSTANCEOF ID (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LSQBRACE to state [87]

-------------------
lalr_state [87]: {
  [instance_of_expr ::= expr INSTANCEOF ID LSQBRACE (*) RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on RSQBRACE to state [88]

-------------------
lalr_state [88]: {
  [instance_of_expr ::= expr INSTANCEOF ID LSQBRACE RSQBRACE (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [89]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr EQ expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [90]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr MODULUS expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [91]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr DIVIDE expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [92]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr MINUS expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [93]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr AND expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [94]: {
  [array_expr ::= ID ID (*) LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LSQBRACE to state [112]

-------------------
lalr_state [95]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= ID LSQBRACE (*) expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= ID LSQBRACE (*) expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [108]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [96]: {
  [dispatch_expr ::= ID LPAREN (*) expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on expr_list to state [106]

-------------------
lalr_state [97]: {
  [assign_expr ::= ID DOT (*) ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= ID DOT (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= ID DOT (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ID to state [98]

-------------------
lalr_state [98]: {
  [array_assign_expr ::= ID DOT ID (*) LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= ID DOT ID (*) ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= ID DOT ID (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ASSIGN to state [100]
transition on LSQBRACE to state [99]

-------------------
lalr_state [99]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= ID DOT ID LSQBRACE (*) expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [102]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [100]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= ID DOT ID ASSIGN (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [101]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [101]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= ID DOT ID ASSIGN expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [102]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= ID DOT ID LSQBRACE expr (*) RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on RSQBRACE to state [103]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [103]: {
  [array_assign_expr ::= ID DOT ID LSQBRACE expr RSQBRACE (*) ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ASSIGN to state [104]

-------------------
lalr_state [104]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= ID DOT ID LSQBRACE expr RSQBRACE ASSIGN (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [105]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [105]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [106]: {
  [dispatch_expr ::= ID LPAREN expr_list (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on RPAREN to state [107]

-------------------
lalr_state [107]: {
  [dispatch_expr ::= ID LPAREN expr_list RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [108]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= ID LSQBRACE expr (*) RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= ID LSQBRACE expr (*) RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on RSQBRACE to state [109]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [109]: {
  [array_expr ::= ID LSQBRACE expr RSQBRACE (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= ID LSQBRACE expr RSQBRACE (*) ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ASSIGN to state [110]

-------------------
lalr_state [110]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= ID LSQBRACE expr RSQBRACE ASSIGN (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [111]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [111]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= ID LSQBRACE expr RSQBRACE ASSIGN expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [112]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= ID ID LSQBRACE (*) expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [113]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [113]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= ID ID LSQBRACE expr (*) RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on RSQBRACE to state [114]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [114]: {
  [array_expr ::= ID ID LSQBRACE expr RSQBRACE (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [115]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= var_expr ASSIGN (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [116]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [116]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= var_expr ASSIGN expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [117]: {
  [expr ::= LPAREN expr (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on RPAREN to state [129]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [118]: {
  [array_expr ::= ID (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [var_expr ::= ID (*) , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [cast_expr ::= LPAREN ID (*) RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= ID (*) DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= ID (*) LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [var_expr ::= ID (*) DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [assign_expr ::= ID (*) DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= ID (*) LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= LPAREN ID (*) LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= ID (*) LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on DOT to state [97]
transition on LPAREN to state [96]
transition on LSQBRACE to state [120]
transition on RPAREN to state [119]
transition on ID to state [94]

-------------------
lalr_state [119]: {
  [cast_expr ::= LPAREN ID RPAREN (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [126]

-------------------
lalr_state [120]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= ID LSQBRACE (*) expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= ID LSQBRACE (*) expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= LPAREN ID LSQBRACE (*) RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on RSQBRACE to state [121]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [108]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [121]: {
  [cast_expr ::= LPAREN ID LSQBRACE RSQBRACE (*) RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on RPAREN to state [122]

-------------------
lalr_state [122]: {
  [cast_expr ::= LPAREN ID LSQBRACE RSQBRACE RPAREN (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [123]

-------------------
lalr_state [123]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN (*) expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [124]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [124]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on RPAREN to state [125]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [125]: {
  [cast_expr ::= LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [126]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= LPAREN ID RPAREN LPAREN (*) expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [127]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [127]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= LPAREN ID RPAREN LPAREN expr (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on RPAREN to state [128]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [128]: {
  [cast_expr ::= LPAREN ID RPAREN LPAREN expr RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [129]: {
  [expr ::= LPAREN expr RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [130]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= DECR expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [131]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= NOT expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [132]: {
  [field ::= ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI (*) , {RBRACE ID }]
}

-------------------
lalr_state [133]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= INCR expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE RSQBRACE SEMI DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [134]: {
  [formal_list ::= formal_list (*) COMMA formal , {RPAREN COMMA }]
  [method ::= ID LSQBRACE RSQBRACE ID LPAREN formal_list (*) RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on RPAREN to state [143]
transition on COMMA to state [142]

-------------------
lalr_state [135]: {
  [formal ::= (*) ID ID , {RPAREN COMMA }]
  [formal ::= (*) ID LSQBRACE RSQBRACE ID , {RPAREN COMMA }]
  [formal_list ::= NT$1 (*) formal , {RPAREN COMMA }]
}
transition on formal to state [137]
transition on ID to state [136]

-------------------
lalr_state [136]: {
  [formal ::= ID (*) ID , {RPAREN COMMA }]
  [formal ::= ID (*) LSQBRACE RSQBRACE ID , {RPAREN COMMA }]
}
transition on LSQBRACE to state [139]
transition on ID to state [138]

-------------------
lalr_state [137]: {
  [formal_list ::= NT$1 formal (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [138]: {
  [formal ::= ID ID (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [139]: {
  [formal ::= ID LSQBRACE (*) RSQBRACE ID , {RPAREN COMMA }]
}
transition on RSQBRACE to state [140]

-------------------
lalr_state [140]: {
  [formal ::= ID LSQBRACE RSQBRACE (*) ID , {RPAREN COMMA }]
}
transition on ID to state [141]

-------------------
lalr_state [141]: {
  [formal ::= ID LSQBRACE RSQBRACE ID (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [142]: {
  [formal_list ::= formal_list COMMA (*) formal , {RPAREN COMMA }]
  [formal ::= (*) ID ID , {RPAREN COMMA }]
  [formal ::= (*) ID LSQBRACE RSQBRACE ID , {RPAREN COMMA }]
}
transition on formal to state [221]
transition on ID to state [136]

-------------------
lalr_state [143]: {
  [method ::= ID LSQBRACE RSQBRACE ID LPAREN formal_list RPAREN (*) LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on LBRACE to state [144]

-------------------
lalr_state [144]: {
  [stmt_list ::= (*) stmt_list stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [NT$2 ::= (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [method ::= ID LSQBRACE RSQBRACE ID LPAREN formal_list RPAREN LBRACE (*) stmt_list RBRACE , {RBRACE ID }]
  [stmt_list ::= (*) NT$2 stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt_list to state [146]
transition on NT$2 to state [145]

-------------------
lalr_state [145]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt_list ::= NT$2 (*) stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [return_stmt ::= (*) RETURN expr , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [220]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [146]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt_list ::= stmt_list (*) stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [method ::= ID LSQBRACE RSQBRACE ID LPAREN formal_list RPAREN LBRACE stmt_list (*) RBRACE , {RBRACE ID }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [164]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on RBRACE to state [161]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [147]: {
  [stmt ::= for_stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [148]: {
  [for_stmt ::= FOR (*) LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR (*) LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR (*) LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR (*) LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR (*) LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR (*) LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR (*) LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR (*) LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [190]

-------------------
lalr_state [149]: {
  [stmt ::= break_stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [150]: {
  [stmt ::= return_stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [151]: {
  [if_stmt ::= IF (*) LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [if_stmt ::= IF (*) LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [184]

-------------------
lalr_state [152]: {
  [decl_stmt ::= ID (*) LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= ID (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [var_expr ::= ID (*) , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [array_assign_expr ::= ID (*) DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= ID (*) LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [var_expr ::= ID (*) DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [assign_expr ::= ID (*) DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= ID (*) LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= ID (*) ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= ID (*) LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on DOT to state [97]
transition on LPAREN to state [96]
transition on LSQBRACE to state [175]
transition on ID to state [174]

-------------------
lalr_state [153]: {
  [stmt ::= decl_stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [154]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_not_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_arith_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [return_stmt ::= RETURN (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instance_of_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) var_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_logic_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [173]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [155]: {
  [stmt ::= block_stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [156]: {
  [stmt ::= expr_stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [157]: {
  [break_stmt ::= BREAK (*) SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on SEMI to state [172]

-------------------
lalr_state [158]: {
  [stmt ::= while_stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [159]: {
  [stmt_list ::= (*) stmt_list stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [NT$2 ::= (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) NT$2 stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [block_stmt ::= LBRACE (*) stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt_list to state [170]
transition on NT$2 to state [145]

-------------------
lalr_state [160]: {
  [while_stmt ::= WHILE (*) LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [166]

-------------------
lalr_state [161]: {
  [method ::= ID LSQBRACE RSQBRACE ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE (*) , {RBRACE ID }]
}

-------------------
lalr_state [162]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= expr (*) SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on SEMI to state [165]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [163]: {
  [stmt ::= if_stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [164]: {
  [stmt_list ::= stmt_list stmt (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [165]: {
  [expr_stmt ::= expr SEMI (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [166]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [while_stmt ::= WHILE LPAREN (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [167]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [167]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [while_stmt ::= WHILE LPAREN expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on RPAREN to state [168]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [168]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [while_stmt ::= WHILE LPAREN expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [169]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [169]: {
  [while_stmt ::= WHILE LPAREN expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [170]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt_list ::= stmt_list (*) stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [block_stmt ::= LBRACE stmt_list (*) RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [164]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on RBRACE to state [171]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [171]: {
  [block_stmt ::= LBRACE stmt_list RBRACE (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [172]: {
  [break_stmt ::= BREAK SEMI (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [173]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [return_stmt ::= RETURN expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [73]
transition on OR to state [72]
transition on LT to state [71]
transition on GEQ to state [70]
transition on NE to state [69]
transition on TIMES to state [68]
transition on GT to state [67]
transition on DOT to state [66]
transition on PLUS to state [65]
transition on INSTANCEOF to state [64]
transition on EQ to state [63]
transition on DECR to state [62]
transition on MODULUS to state [61]
transition on DIVIDE to state [60]
transition on MINUS to state [59]
transition on AND to state [58]
transition on INCR to state [57]

-------------------
lalr_state [174]: {
  [array_expr ::= ID ID (*) LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [decl_stmt ::= ID ID (*) ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ASSIGN to state [181]
transition on LSQBRACE to state [112]

-------------------
lalr_state [175]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [decl_stmt ::= ID LSQBRACE (*) RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= ID LSQBRACE (*) expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= ID LSQBRACE (*) expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RSQBRACE DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RSQBRACE DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on RSQBRACE to state [176]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [108]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [176]: {
  [decl_stmt ::= ID LSQBRACE RSQBRACE (*) ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ID to state [177]

-------------------
lalr_state [177]: {
  [decl_stmt ::= ID LSQBRACE RSQBRACE ID (*) ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ASSIGN to state [178]

-------------------
lalr_state [178]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= ID LSQBRACE RSQBRACE ID ASSIGN (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [179]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [179]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= ID LSQBRACE RSQBRACE ID ASSIGN expr (*) SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on SEMI to state [180]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [180]: {
  [decl_stmt ::= ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [181]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= ID ID ASSIGN (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [182]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [182]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= ID ID ASSIGN expr (*) SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on SEMI to state [183]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [183]: {
  [decl_stmt ::= ID ID ASSIGN expr SEMI (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [184]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [if_stmt ::= IF LPAREN (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [if_stmt ::= IF LPAREN (*) expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [185]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [185]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [if_stmt ::= IF LPAREN expr (*) RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [if_stmt ::= IF LPAREN expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on RPAREN to state [186]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [186]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [if_stmt ::= IF LPAREN expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [if_stmt ::= IF LPAREN expr RPAREN (*) stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [187]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [187]: {
  [if_stmt ::= IF LPAREN expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [if_stmt ::= IF LPAREN expr RPAREN stmt (*) ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ELSE to state [188]

-------------------
lalr_state [188]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [if_stmt ::= IF LPAREN expr RPAREN stmt ELSE (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [189]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [189]: {
  [if_stmt ::= IF LPAREN expr RPAREN stmt ELSE stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [190]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN (*) SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN (*) SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN (*) expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN (*) expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN (*) SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN (*) SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN (*) expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN (*) expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on SEMI to state [192]
transition on unary_decr_expr to state [29]
transition on expr to state [191]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [191]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr (*) SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr (*) SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr (*) SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr (*) SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on SEMI to state [206]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [192]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN SEMI (*) SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN SEMI (*) SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN SEMI (*) expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN SEMI (*) expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on SEMI to state [194]
transition on unary_decr_expr to state [29]
transition on expr to state [193]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [193]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN SEMI expr (*) SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN SEMI expr (*) SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on SEMI to state [200]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [194]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN SEMI SEMI (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN SEMI SEMI (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on RPAREN to state [196]
transition on unary_decr_expr to state [29]
transition on expr to state [195]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [195]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN SEMI SEMI expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on RPAREN to state [198]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [196]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR LPAREN SEMI SEMI RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [197]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [197]: {
  [for_stmt ::= FOR LPAREN SEMI SEMI RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [198]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR LPAREN SEMI SEMI expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [199]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [199]: {
  [for_stmt ::= FOR LPAREN SEMI SEMI expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [200]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN SEMI expr SEMI (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN SEMI expr SEMI (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on RPAREN to state [202]
transition on expr to state [201]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [201]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN SEMI expr SEMI expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on RPAREN to state [204]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [202]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR LPAREN SEMI expr SEMI RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [203]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [203]: {
  [for_stmt ::= FOR LPAREN SEMI expr SEMI RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [204]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR LPAREN SEMI expr SEMI expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [205]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [205]: {
  [for_stmt ::= FOR LPAREN SEMI expr SEMI expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [206]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI (*) SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI (*) SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI (*) expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI (*) expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on SEMI to state [208]
transition on unary_decr_expr to state [29]
transition on expr to state [207]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [207]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI expr (*) SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI expr (*) SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on SEMI to state [214]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [208]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI SEMI (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI SEMI (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on RPAREN to state [210]
transition on unary_decr_expr to state [29]
transition on expr to state [209]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [209]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI SEMI expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on RPAREN to state [212]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [210]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR LPAREN expr SEMI SEMI RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [211]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [211]: {
  [for_stmt ::= FOR LPAREN expr SEMI SEMI RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [212]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR LPAREN expr SEMI SEMI expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [213]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [213]: {
  [for_stmt ::= FOR LPAREN expr SEMI SEMI expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [214]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI expr SEMI (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI expr SEMI (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on RPAREN to state [216]
transition on expr to state [215]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [215]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI expr SEMI expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on RPAREN to state [218]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [216]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [for_stmt ::= FOR LPAREN expr SEMI expr SEMI RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [217]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [217]: {
  [for_stmt ::= FOR LPAREN expr SEMI expr SEMI RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [218]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= FOR LPAREN expr SEMI expr SEMI expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [219]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [219]: {
  [for_stmt ::= FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [220]: {
  [stmt_list ::= NT$2 stmt (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [221]: {
  [formal_list ::= formal_list COMMA formal (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [222]: {
  [field ::= ID ID SEMI (*) , {RBRACE ID }]
}

-------------------
lalr_state [223]: {
  [formal_list ::= (*) NT$1 formal , {RPAREN COMMA }]
  [formal_list ::= (*) formal_list COMMA formal , {RPAREN COMMA }]
  [method ::= ID ID LPAREN (*) formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [NT$1 ::= (*) , {ID }]
  [formal_list ::= (*) , {RPAREN COMMA }]
}
transition on NT$1 to state [135]
transition on formal_list to state [227]

-------------------
lalr_state [224]: {
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [field ::= ID ID ASSIGN (*) expr SEMI , {RBRACE ID }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on binary_expr to state [52]
transition on binary_logic_expr to state [51]
transition on const_expr to state [50]
transition on array_expr to state [49]
transition on NEW to state [48]
transition on binary_arith_expr to state [47]
transition on dispatch_expr to state [46]
transition on unary_not_expr to state [45]
transition on unary_neg_expr to state [44]
transition on MINUS to state [43]
transition on unary_incr_expr to state [42]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on INT_CONST to state [39]
transition on ID to state [38]
transition on array_assign_expr to state [37]
transition on var_expr to state [36]
transition on LPAREN to state [35]
transition on BOOLEAN_CONST to state [34]
transition on DECR to state [33]
transition on new_expr to state [32]
transition on NOT to state [31]
transition on instance_of_expr to state [30]
transition on unary_decr_expr to state [29]
transition on expr to state [225]
transition on cast_expr to state [27]
transition on assign_expr to state [26]
transition on INCR to state [25]
transition on STRING_CONST to state [24]

-------------------
lalr_state [225]: {
  [dispatch_expr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_logic_expr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_decr_expr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_arith_expr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [field ::= ID ID ASSIGN expr (*) SEMI , {RBRACE ID }]
  [binary_logic_expr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unary_incr_expr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [61]
transition on INSTANCEOF to state [64]
transition on LEQ to state [73]
transition on EQ to state [63]
transition on DOT to state [66]
transition on MINUS to state [59]
transition on DIVIDE to state [60]
transition on GT to state [67]
transition on DECR to state [62]
transition on SEMI to state [226]
transition on OR to state [72]
transition on PLUS to state [65]
transition on NE to state [69]
transition on LT to state [71]
transition on INCR to state [57]
transition on AND to state [58]
transition on GEQ to state [70]
transition on TIMES to state [68]

-------------------
lalr_state [226]: {
  [field ::= ID ID ASSIGN expr SEMI (*) , {RBRACE ID }]
}

-------------------
lalr_state [227]: {
  [method ::= ID ID LPAREN formal_list (*) RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [formal_list ::= formal_list (*) COMMA formal , {RPAREN COMMA }]
}
transition on RPAREN to state [228]
transition on COMMA to state [142]

-------------------
lalr_state [228]: {
  [method ::= ID ID LPAREN formal_list RPAREN (*) LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on LBRACE to state [229]

-------------------
lalr_state [229]: {
  [method ::= ID ID LPAREN formal_list RPAREN LBRACE (*) stmt_list RBRACE , {RBRACE ID }]
  [stmt_list ::= (*) stmt_list stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [NT$2 ::= (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) NT$2 stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt_list to state [230]
transition on NT$2 to state [145]

-------------------
lalr_state [230]: {
  [binary_arith_expr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) var_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) block_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_neg_expr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_decr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt_list ::= stmt_list (*) stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_comp_expr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr_stmt ::= (*) expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_not_expr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_expr ::= (*) ID ID LSQBRACE expr RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [const_expr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatch_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) expr_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) var_expr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [cast_expr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) new_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) decl_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [method ::= ID ID LPAREN formal_list RPAREN LBRACE stmt_list (*) RBRACE , {RBRACE ID }]
  [binary_comp_expr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) ID DOT ID ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [decl_stmt ::= (*) ID ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_incr_expr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_arith_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [array_assign_expr ::= (*) ID DOT ID LSQBRACE expr RSQBRACE ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [const_expr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instance_of_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) if_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assign_expr ::= (*) array_assign_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_comp_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) cast_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) while_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [if_stmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unary_decr_expr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binary_expr ::= (*) binary_logic_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) for_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_comp_expr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatch_expr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [while_stmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID DOT ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_neg_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [break_stmt ::= (*) BREAK SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unary_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) break_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [new_expr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_not_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [return_stmt ::= (*) RETURN expr , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_arith_expr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) const_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) return_stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binary_logic_expr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instance_of_expr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [for_stmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [var_expr ::= (*) array_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unary_expr ::= (*) unary_incr_expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [block_stmt ::= (*) LBRACE stmt_list RBRACE , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [164]
transition on unary_neg_expr to state [44]
transition on STRING_CONST to state [24]
transition on BOOLEAN_CONST to state [34]
transition on if_stmt to state [163]
transition on expr to state [162]
transition on RBRACE to state [231]
transition on array_assign_expr to state [37]
transition on WHILE to state [160]
transition on cast_expr to state [27]
transition on binary_logic_expr to state [51]
transition on LBRACE to state [159]
transition on unary_not_expr to state [45]
transition on binary_expr to state [52]
transition on while_stmt to state [158]
transition on BREAK to state [157]
transition on expr_stmt to state [156]
transition on NEW to state [48]
transition on INT_CONST to state [39]
transition on block_stmt to state [155]
transition on RETURN to state [154]
transition on binary_arith_expr to state [47]
transition on decl_stmt to state [153]
transition on ID to state [152]
transition on IF to state [151]
transition on instance_of_expr to state [30]
transition on const_expr to state [50]
transition on return_stmt to state [150]
transition on binary_comp_expr to state [41]
transition on unary_expr to state [40]
transition on NOT to state [31]
transition on dispatch_expr to state [46]
transition on assign_expr to state [26]
transition on break_stmt to state [149]
transition on MINUS to state [43]
transition on FOR to state [148]
transition on INCR to state [25]
transition on unary_decr_expr to state [29]
transition on DECR to state [33]
transition on LPAREN to state [35]
transition on array_expr to state [49]
transition on var_expr to state [36]
transition on new_expr to state [32]
transition on for_stmt to state [147]
transition on unary_incr_expr to state [42]

-------------------
lalr_state [231]: {
  [method ::= ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE (*) , {RBRACE ID }]
}

-------------------
lalr_state [232]: {
  [member_list ::= NT$0 member (*) , {RBRACE ID }]
}

-------------------
lalr_state [233]: {
  [field ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= (*) ID ID SEMI , {RBRACE ID }]
  [member ::= (*) field , {RBRACE ID }]
  [class ::= CLASS ID LBRACE member_list (*) RBRACE , {EOF CLASS }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID SEMI , {RBRACE ID }]
  [method ::= (*) ID LSQBRACE RSQBRACE ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [member ::= (*) method , {RBRACE ID }]
  [field ::= (*) ID ID ASSIGN expr SEMI , {RBRACE ID }]
  [member_list ::= member_list (*) member , {RBRACE ID }]
  [method ::= (*) ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on method to state [16]
transition on member to state [15]
transition on field to state [14]
transition on RBRACE to state [234]
transition on ID to state [12]

-------------------
lalr_state [234]: {
  [class ::= CLASS ID LBRACE member_list RBRACE (*) , {EOF CLASS }]
}

-------------------
lalr_state [235]: {
  [$START ::= program EOF (*) , {EOF }]
}

-------------------
lalr_state [236]: {
  [class_list ::= class_list class (*) , {EOF CLASS }]
}

-------------------
Closing files...
------- CUP v0.10k Parser Generation Summary -------
  1 error and 107 warnings
  43 terminals, 43 non-terminals, and 109 productions declared, 
  producing 237 unique parse states.
  1 terminal declared but not used.
  0 non-terminal declared but not used.
  0 productions never reduced.
  106 conflicts detected (100 expected).
  No code produced.
---------------------------------------------------- (v0.10k)
